Index: codereview/views.py
===================================================================
--- codereview/views.py	(Revision 329)
+++ codereview/views.py	(Arbeitskopie)
@@ -616,8 +616,8 @@
       user))
   review_issues = [issue for issue in db.GqlQuery(
       'SELECT * FROM Issue '
-      'WHERE closed = FALSE AND reviewers = :1 ORDER BY modified DESC',
-      user.email()) if issue.owner != user]
+      'WHERE closed = FALSE ORDER BY modified DESC')
+      if issue.owner != user and user.email in issue.reviewers]
   closed_issues = list(db.GqlQuery(
       'SELECT * FROM Issue '
       'WHERE closed = TRUE AND modified > :1 AND owner = :2 '
@@ -625,7 +625,7 @@
       datetime.datetime.now() - datetime.timedelta(days=7), user))
   _optimize_draft_counts(my_issues + review_issues + closed_issues)
   return respond(request, 'user.html',
-                 {'email': user.email(),
+                 {'email':user.email,
                   'my_issues': my_issues,
                   'review_issues': review_issues,
                   'closed_issues': closed_issues,
@@ -995,7 +995,7 @@
             accounts = models.Account.get_accounts_for_nickname(email)
             if len(accounts) != 1:
               raise db.BadValueError('Unknown user: %s' % email)
-            email = db.Email(accounts[0].user.email())
+            email = db.Email(accounts[0].user.email)
           elif email.count('@') != 1:
             raise db.BadValueError('Invalid email address: %s' % email)
           else:
@@ -1653,11 +1653,11 @@
   if request.method != 'POST':
     reviewers = issue.reviewers[:]
     cc = issue.cc[:]
-    if request.user != issue.owner and (request.user.email()
+    if request.user != issue.owner and (request.user.email
                                         not in issue.reviewers):
-      reviewers.append(request.user.email())
-      if request.user.email() in cc:
-        cc.remove(request.user.email())
+      reviewers.append(request.user.email)
+      if request.user.email in cc:
+        cc.remove(request.user.email)
     reviewers = [models.Account.get_nickname_for_email(reviewer,
                                                        default=reviewer)
                  for reviewer in reviewers]
@@ -1683,15 +1683,15 @@
     reviewers = _get_emails(form, 'reviewers')
   else:
     reviewers = issue.reviewers
-    if request.user != issue.owner and request.user.email() not in reviewers:
-      reviewers.append(db.Email(request.user.email()))
+    if request.user != issue.owner and request.user.email not in reviewers:
+      reviewers.append(db.Email(request.user.email))
   if form.is_valid() and not form.cleaned_data.get('message_only', False):
     cc = _get_emails(form, 'cc')
   else:
     cc = issue.cc
     # The user is in the reviewer list, remove them from CC if they're there.
-    if request.user.email() in cc:
-      cc.remove(request.user.email())
+    if request.user.email in cc:
+      cc.remove(request.user.email)
   if not form.is_valid():
     return respond(request, 'publish.html', {'form': form, 'issue': issue})
   issue.reviewers = reviewers
@@ -1821,8 +1821,8 @@
   """Helper to create a Message instance and optionally send an email."""
   template, context = _get_mail_template(issue)
   # Decide who should receive mail
-  my_email = db.Email(request.user.email())
-  to = [db.Email(issue.owner.email())] + issue.reviewers
+  my_email = db.Email(request.user.email)
+  to = [db.Email(issue.owner.email)] + issue.reviewers
   cc = issue.cc[:]
   reply_to = to + cc
   if my_email in to and len(to) > 1:  # send_mail() wants a non-empty to list
@@ -2098,7 +2098,7 @@
 
 def _user_popup(request):
   user = request.user_to_show
-  popup_html = memcache.get('user_popup:' + user.email())
+  popup_html = memcache.get('user_popup:' + user.email)
   if popup_html is None:
     num_issues_created = db.GqlQuery(
       'SELECT * FROM Issue '
@@ -2109,12 +2109,12 @@
       'WHERE closed = FALSE AND reviewers = :1',
       user).count()
 
-    user.nickname = models.Account.get_nickname_for_email(user.email())
+    user.nickname = models.Account.get_nickname_for_email(user.email)
     popup_html = render_to_response('user_popup.html',
                             {'user': user,
                              'num_issues_created': num_issues_created,
                              'num_issues_reviewed': num_issues_reviewed,
                              })
     # Use time expired cache because the number of issues will change over time
-    memcache.add('user_popup:' + user.email(), popup_html, 60)
+    memcache.add('user_popup:' + user.email, popup_html, 60)
   return popup_html
