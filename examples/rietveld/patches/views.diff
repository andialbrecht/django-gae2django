Index: codereview/views.py
===================================================================
--- codereview/views.py	(revision 394)
+++ codereview/views.py	(working copy)
@@ -580,6 +580,8 @@
   issues = query.fetch(limit+1, offset)
   more = bool(issues[limit:])
   if more:
+    # item deletion not supported by Django's QuerySet.
+    issues = list(issues)
     del issues[limit:]
   if more:
     next = '/all?offset=%d&limit=%d' % (offset+limit, limit)
@@ -658,8 +660,8 @@
       user))
   review_issues = [issue for issue in db.GqlQuery(
       'SELECT * FROM Issue '
-      'WHERE closed = FALSE AND reviewers = :1 ORDER BY modified DESC',
-      user.email()) if issue.owner != user]
+      'WHERE closed = FALSE ORDER BY modified DESC')
+      if issue.owner != user and user.email in issue.reviewers]
   closed_issues = list(db.GqlQuery(
       'SELECT * FROM Issue '
       'WHERE closed = TRUE AND modified > :1 AND owner = :2 '
@@ -667,7 +669,7 @@
       datetime.datetime.now() - datetime.timedelta(days=7), user))
   _optimize_draft_counts(my_issues + review_issues + closed_issues)
   return respond(request, 'user.html',
-                 {'email': user.email(),
+                 {'email':user.email,
                   'my_issues': my_issues,
                   'review_issues': review_issues,
                   'closed_issues': closed_issues,
@@ -1071,7 +1073,7 @@
             accounts = models.Account.get_accounts_for_nickname(email)
             if len(accounts) != 1:
               raise db.BadValueError('Unknown user: %s' % email)
-            db_email = db.Email(accounts[0].user.email().lower())
+            db_email = db.Email(accounts[0].user.email.lower())
           elif email.count('@') != 1:
             raise db.BadValueError('Invalid email address: %s' % email)
           else:
@@ -1282,7 +1284,7 @@
 
     accounts = models.Account.all()
     accounts.filter("lower_%s >= " % property, query)
-    accounts.filter("lower_%s < " % property, query + u"\ufffd")
+    accounts.filter("lower_%s < " % property, query + u"\\ufffd")
     accounts.order("lower_%s" % property);
     for account in accounts:
       if account.key() in added:
@@ -1918,11 +1920,11 @@
   if request.method != 'POST':
     reviewers = issue.reviewers[:]
     cc = issue.cc[:]
-    if request.user != issue.owner and (request.user.email()
+    if request.user != issue.owner and (request.user.email
                                         not in issue.reviewers):
-      reviewers.append(request.user.email())
-      if request.user.email() in cc:
-        cc.remove(request.user.email())
+      reviewers.append(request.user.email)
+      if request.user.email in cc:
+        cc.remove(request.user.email)
     reviewers = [models.Account.get_nickname_for_email(reviewer,
                                                        default=reviewer)
                  for reviewer in reviewers]
@@ -1954,15 +1956,15 @@
     reviewers = _get_emails(form, 'reviewers')
   else:
     reviewers = issue.reviewers
-    if request.user != issue.owner and request.user.email() not in reviewers:
-      reviewers.append(db.Email(request.user.email()))
+    if request.user != issue.owner and request.user.email not in reviewers:
+      reviewers.append(db.Email(request.user.email))
   if form.is_valid() and not form.cleaned_data.get('message_only', False):
     cc = _get_emails(form, 'cc')
   else:
     cc = issue.cc
     # The user is in the reviewer list, remove them from CC if they're there.
-    if request.user.email() in cc:
-      cc.remove(request.user.email())
+    if request.user.email in cc:
+      cc.remove(request.user.email)
   if not form.is_valid():
     return respond(request, 'publish.html', {'form': form, 'issue': issue})
   issue.reviewers = reviewers
@@ -2029,7 +2031,10 @@
         # Get the patch key value without loading the patch entity.
         # NOTE: Unlike the old version of this code, this is the
         # recommended and documented way to do this!
-        pkey = models.Comment.patch.get_value_for_datastore(c)
+        # pkey = models.Comment.patch.get_value_for_datastore(c)
+        # FIXME(andi): see Issue 1
+        #   http://code.google.com/p/django-gae2django/issues/detail?id=1
+        pkey = getattr(c, '_patch', None)
         if pkey in patches:
           patch = patches[pkey]
           c.patch = patch
@@ -2097,8 +2102,8 @@
   """Helper to create a Message instance and optionally send an email."""
   template, context = _get_mail_template(request, issue)
   # Decide who should receive mail
-  my_email = db.Email(request.user.email())
-  to = [db.Email(issue.owner.email())] + issue.reviewers
+  my_email = db.Email(request.user.email)
+  to = [db.Email(issue.owner.email)] + issue.reviewers
   cc = issue.cc[:]
   reply_to = to + cc
   if my_email in to and len(to) > 1:  # send_mail() wants a non-empty to list
@@ -2443,7 +2448,7 @@
 
 def _user_popup(request):
   user = request.user_to_show
-  popup_html = memcache.get('user_popup:' + user.email())
+  popup_html = memcache.get('user_popup:' + user.email)
   if popup_html is None:
     num_issues_created = db.GqlQuery(
       'SELECT * FROM Issue '
@@ -2454,12 +2459,12 @@
       'WHERE closed = FALSE AND reviewers = :1',
       user.email()).count()
 
-    user.nickname = models.Account.get_nickname_for_email(user.email())
+    user.nickname = models.Account.get_nickname_for_email(user.email)
     popup_html = render_to_response('user_popup.html',
                             {'user': user,
                              'num_issues_created': num_issues_created,
                              'num_issues_reviewed': num_issues_reviewed,
                              })
     # Use time expired cache because the number of issues will change over time
-    memcache.add('user_popup:' + user.email(), popup_html, 60)
+    memcache.add('user_popup:' + user.email, popup_html, 60)
   return popup_html
